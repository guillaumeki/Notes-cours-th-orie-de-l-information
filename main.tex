\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{calrsfs}
\usepackage{stmaryrd}
\usepackage{minted}
\usepackage{fancyhdr}
\usepackage[inline]{asymptote} 
\usepackage[linesnumbered,ruled,french,onelanguage]{algorithm2e}
\SetKwComment{Comment}{$\triangleright$\ }{}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    linktoc=section,
    linkcolor=red,
    urlcolor=orange,
    filecolor=red
}
\usepackage{times}
\usepackage{todonotes}
\usepackage{latexsym}
\usepackage{verbatim}
\usepackage{amsmath,amssymb}
\usepackage{upgreek}
\usepackage{dsfont}
\usepackage{framed}
\usepackage{amsfonts}
\newcommand{\tocheck}[1]{\textcolor{blue}{#1}}
\newcommand{\overbar}[1]{\mkern 3mu\overline{\mkern-3mu#1\mkern-3mu}\mkern 3mu}
\usepackage{fullpage,setspace}
\linespread{1.5}
\usepackage{enumerate}
\usepackage{mathrsfs}
\usepackage{amsthm}
\theoremstyle{definition}
\newtheorem{lemma}{Lemme}
\newtheorem{theorem}{Théorème}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{definition}{Définition}
\newtheorem{heuristique}{Heuristique}
\newtheorem{scenario}{Scénario}
\newtheorem{fact}{Fait}
\newtheorem{example}{Exemple}
\newtheorem{postulate}{Postulat}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollaire}
\newtheorem{property}{Propriété}
\numberwithin{lemma}{subsection}
\numberwithin{theorem}{subsection}
\numberwithin{definition}{subsection}
\numberwithin{proposition}{subsection}
\numberwithin{corollary}{subsection}
\numberwithin{property}{subsection}
\numberwithin{example}{subsection}
\numberwithin{heuristique}{subsection}
\numberwithin{scenario}{subsection}
\newenvironment{proofi} {\noindent\emph{Proof:}} {\hfill $\square$\vspace{0.2cm}}
\newcommand{\eod}{\ensuremath{\hfill\dashv}}
\newcommand{\eop}{\ensuremath{\hfill\clubsuit}}
\newcommand{\fun}[1]{\ensuremath{\mbox{\it #1}}}
\newcommand{\expo}[2]{{#1}^{\mbox{\scriptsize \sl #2}}}
\newcommand{\var}{\ensuremath{\mathbf{var}}\xspace}
\newcommand{\exv}{\ensuremath{\mathbf{exv}}\xspace}
\newcommand{\dsv}{\ensuremath{\mathbf{dsv}}\xspace}
\newcommand{\term}{\ensuremath{\mathbf{term}}\xspace}
\newcommand{\pred}{\ensuremath{\mathbf{pred}}\xspace}
\newcommand{\fr}{\ensuremath{\mathbf{fr}}\xspace}
\newcommand{\cnst}{\ensuremath{\mathbf{cnst}}\xspace}
\newcommand{\Vars}{\ensuremath{\mathsf{Vars}}\xspace}
\newcommand{\Pvars}{\ensuremath{\mathsf{Pvars}}\xspace}
\newcommand{\Fvars}{\ensuremath{\mathsf{Fvars}}\xspace}
\newcommand{\Terms}{\ensuremath{\mathsf{Terms}}\xspace}
\newcommand{\Cons}{\ensuremath{\mathsf{Const}}\xspace}
\newcommand{\Preds}{\ensuremath{\mathsf{Preds}}\xspace}
\newcommand{\ic}{\ensuremath{\cdot\{}\xspace}
\newcommand{\ci}{\ensuremath{\}\cdot}\xspace}
\newcommand{\id}{\ensuremath{:\hspace{-1.56mm}\{}\xspace}
\newcommand{\di}{\ensuremath{\}\hspace{-1.56mm}:}\xspace}
\newcommand{\bet}{\ensuremath{\beta^{\diamond}}\xspace}
\newcommand{\sep}{\ensuremath{\mathbf{sep}}\xspace}
\newcommand{\vect}[1]{\mathbf{#1}}
\newcommand{\vars}[1]{\fun{vars}{(#1)}}
\newcommand{\terms}[1]{\fun{terms}{(#1)}}
\newcommand{\atoms}[1]{\fun{atoms}{(#1)}}
\newcommand{\type}[1]{\fun{type}{(#1)}}
\newcommand{\const}{a}
\newcommand{\atom}{\alpha}

\newcounter{deuxfois}
\newcommand{\sig}{\ensuremath{\mathbf{sig}}\xspace}

\usepackage{color}
\definecolor{gren}{rgb}{0.158, 0.488, 0.408}
\definecolor{bren}{rgb}{0.45, 0.21, 0.000}

\title{Notes de cours d'informatique théorique (HMIN 118)}
\author{Guillaume Pérution-Kihli}
\begin{document}
\maketitle
\renewcommand{\contentsname}{Sommaire}
\tableofcontents
\pagebreak

\section{Théorie de l'information de Shannon}
	\subsection{Mesure de l'information de Hartley}
	
L'information est le nombre de réponses possible.
\par Hartley suppose que pour composer un message, il faut avoir un alphabet dans lequel le composer. Cet alphabet doit comporter un nombre fini $s$ de symboles. Un message comportant $n$ symboles tirés d'un alphabet de taille $s$ n'est donc qu'un parmi les $s^n$ messages possibles.
\par D'après Hartley, la quantité d'information intrinsèque au message doit être proportionnelle à sa longueur fois une quantité qui ne dépend que du nombre de symboles de l'alphabet. Autrement dit, la quantité d'information $H$ d'un message de longueur $n$ est de la forme $H = k * n$ où la constante $k$ est à déterminer.
\par Pour obtenir la fonction désirée, Hartley propose d'utiliser le logarithme et de calculer $$H = log(s^n) = n*log(s) $$.
\par Ce logarithme peut avoir différentes bases, et l'unité de mesure de l'information change en fonction de ces bases.
\par
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
base &  & nom de l'unité \\
\hline
$2$ & $2 (log_2)$ & bit \\
\hline
$e$ & $e (ln)$ & nat \\
\hline
$10$ & $10(log_{10})$ & hartley \\
\hline
\end{tabular}
\end{center}

\par Cette méthode de mesure a cependant un important défaut : tous les symboles du message sont considérés comme contenant la même quantité d'information puisqu'on les multiplie tous par la même constante.

	\subsection{Mesure de l'information de Shannon}

Pour Shannon, l'unité d'information est le bit. Avec le bit comme mesure, l’information devient une notion essentiellement probabiliste donc quantifiable. Et s’il y a beaucoup de manières de passer un message en binaire, il n’y en a qu’une qui permette de réaliser la quantité d’information de Shannon. L’entropie de Shannon mesure la quantité d’information d’un message : un signal peu informatif est redondant et donc prédictible d’un point de vue des probabilités, alors qu’un signal très informatif est très diversifié et donc peu prédictible.
\par Pour une source, qui est une variable aléatoire discrète $X$ comportant $n$ symboles, chaque symbole $x_i$ ayant une probabilité $P_i$ d'apparaître, l'entropie $H$ de la source $X$ est définie comme :
$$H_b(X)= -\mathbb E [\log_b {P(X)}] = \sum_{i=1}^nP_i\log_b \left(\frac{1}{P_i}\right)=-\sum_{i=1}^nP_i\log_b P_i.\,\!$$
où $\mathbb  E$ désigne l'espérance mathématique, et $\log _{b}$ le logarithme en base $b$. On utilise en général un logarithme à base 2 car l'entropie possède alors les unités de bit/symbole. Les symboles représentent les réalisations possibles de la variable aléatoire $X$. Dans ce cas, on peut interpréter $H(X)$ comme le nombre de questions à réponse oui/non que doit poser en moyenne le récepteur à la source, ou la quantité d'information en bits que la source doit fournir au récepteur pour que ce dernier puisse déterminer sans ambiguïté la valeur de $X$.
$$H(X)=H_2(X)= -\sum_{i=1}^nP_i\log_2 P_i.\,\!$$

\begin{example}\label{ex:entropie_shannon}
Prenons $X = yabadabadoo$. On obtient la répartition qui suit :
\par\begin{tabular}{|c|c|c|c|c|c|}
\hline
Symbole & a & b & d & o & y \\
\hline
Nombre d'occurrences & 4 & 2 & 2 & 2 & 1 \\
\hline
Probabilité d'apparition $P_i$ & $\frac{4}{11}$ & $\frac{2}{11}$ & $\frac{2}{11}$ & $\frac{2}{11}$ & $\frac{1}{11}$ \\
\hline
\end{tabular}
\par L'entropie de $X$ est :
$$H(X) = -\sum_{i=1}^5P_i\log_2 P_i = -(\frac{4}{11}\log_2\frac{4}{11}+3*
(\frac{2}{11}\log_2\frac{2}{11})+
\frac{1}{11}\log_2\frac{1}{11}) \simeq 2.19$$
\end{example}

\section{Codes et techniques de compression}
	\subsection{Codes, codes préfixes et inégalité de Kraft}

\begin{scenario}
A veut transmettre quelques informations à B.
\end{scenario}

$element \in \chi \rightarrow chaine ~binaire$

\begin{definition}{Fonction de décodage}
\par $D : {0,1}^* \rightarrow \chi$.
\par $E = D^{-1}$.
\end{definition}

\begin{theorem}{Inégalité de Kraft}
\par Il existe un code uniquement décodable sur un alphabet de taille $r$, avec $n$ mots de code de tailles $l_1, l_2, ..., l_n$, ssi $$\sum_{i=1}^n r^{-l_i} \leqslant 1$$
\end{theorem}

\begin{definition}{Sans préfixe}
\par Un code est dit sans préfixe si aucun mot de code n'est préfixe d'un autre.
\end{definition}

	\subsection{Codage de Shannon-Fano}
	
Le codage de Shannon-Fano est un algorithme de compression de données sans perte élaboré par Robert Fano à partir d'une idée de Claude Shannon.
Il s'agit d'un codage entropique produisant un code préfixe très similaire à un code de Huffman, bien que pas toujours optimal, contrairement à ce dernier.

\begin{algorithm}[H]
\caption{Algorithme de Shannon-Fano}
Pour chaque symbole, compter la fréquence d'apparition\;
Les ordonner des plus fréquents aux moins fréquents \;
Diviser la liste de symboles en deux parties de façon à avoir des totaux proches \;
Assigner 0 à la partie gauche de la division, et 1 à la partie droite \;
Recommencer les étapes 3 et 4\;
\end{algorithm}

\begin{example}
Reprenons l'exemple \ref{ex:entropie_shannon}. On obtient la liste de symboles ordonnés : $<(a:4), (b:2), (d:2), (o:2), (y:1)>$.
\par On va diviser cette liste une première fois en deux listes ayant à peu près les mêmes nombres d'occurrences, qu'on va représenter sous forme d'arbre :
%:-+-+-+- Engendré par : http://math.et.info.free.fr/TikZ/Arbre/
\begin{center}
% Racine en Haut, développement vers le bas
\begin{tikzpicture}[xscale=1,yscale=1]
% Styles (MODIFIABLES)
\tikzstyle{fleche}=[->,>=latex,thick]
\tikzstyle{noeud}=[fill=lightgray,rectangle,draw]
\tikzstyle{feuille}=[fill=lightgray,rectangle,draw]
\tikzstyle{etiquette}=[midway,fill=white]
% Dimensions (MODIFIABLES)
\def\DistanceInterNiveaux{3}
\def\DistanceInterFeuilles{2}
% Dimensions calculées (NON MODIFIABLES)
\def\NiveauA{(-0)*\DistanceInterNiveaux}
\def\NiveauB{(-0.7)*\DistanceInterNiveaux}
\def\InterFeuilles{(1)*\DistanceInterFeuilles}
% Noeuds (MODIFIABLES : Styles et Coefficients d'InterFeuilles)
\node[noeud] (R) at ({(1)*\InterFeuilles},{\NiveauA}) {$11$};
\node[feuille] (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {$6: (a:4), (b:2)$};
\node[feuille] (Rb) at ({(2)*\InterFeuilles},{\NiveauB}) {$5: (d:2), (o:2), (y:1)$};
% Arcs (MODIFIABLES : Styles)
\draw[fleche] (R)--(Ra) node[etiquette] {$0$};
\draw[fleche] (R)--(Rb) node[etiquette] {$1$};
\end{tikzpicture}
\end{center}
On répète le processus jusqu'à obtenir un arbre où chaque feuille représente un symbole :
%:-+-+-+- Engendré par : http://math.et.info.free.fr/TikZ/Arbre/
\begin{center}
% Racine en Haut, développement vers le bas
\begin{tikzpicture}[xscale=1,yscale=1]
% Styles (MODIFIABLES)
\tikzstyle{fleche}=[->,>=latex,thick]
\tikzstyle{noeud}=[fill=lightgray,rectangle,draw]
\tikzstyle{feuille}=[fill=lightgray,rectangle,draw]
\tikzstyle{etiquette}=[midway,fill=white]
% Dimensions (MODIFIABLES)
\def\DistanceInterNiveaux{3}
\def\DistanceInterFeuilles{2}
% Dimensions calculées (NON MODIFIABLES)
\def\NiveauA{(-0)*\DistanceInterNiveaux}
\def\NiveauB{(-0.7)*\DistanceInterNiveaux}
\def\NiveauC{(-1.4)*\DistanceInterNiveaux}
\def\InterFeuilles{(1)*\DistanceInterFeuilles}
% Noeuds (MODIFIABLES : Styles et Coefficients d'InterFeuilles)
\node[noeud] (R) at ({(1.5)*\InterFeuilles},{\NiveauA}) {$11$};
\node[noeud] (Ra) at ({(0.5)*\InterFeuilles},{\NiveauB}) {$6$};
\node[feuille] (Raa) at ({(0)*\InterFeuilles},{\NiveauC}) {$a$};
\node[feuille] (Rab) at ({(1)*\InterFeuilles},{\NiveauC}) {$b$};
\node[noeud] (Rb) at ({(2.5)*\InterFeuilles},{\NiveauB}) {$5$};
\node[feuille] (Rba) at ({(2)*\InterFeuilles},{\NiveauC}) {$3: (d:2), (y:1)$};
\node[feuille] (Rbb) at ({(3)*\InterFeuilles},{\NiveauC}) {$o$};
% Arcs (MODIFIABLES : Styles)
\draw[fleche] (R)--(Ra) node[etiquette] {$0$};
\draw[fleche] (Ra)--(Raa) node[etiquette] {$0$};
\draw[fleche] (Ra)--(Rab) node[etiquette] {$1$};
\draw[fleche] (R)--(Rb) node[etiquette] {$1$};
\draw[fleche] (Rb)--(Rba) node[etiquette] {$0$};
\draw[fleche] (Rb)--(Rbb) node[etiquette] {$1$};
\end{tikzpicture}
\end{center}
%:-+-+-+- Engendré par : http://math.et.info.free.fr/TikZ/Arbre/
\begin{center}
% Racine en Haut, développement vers le bas
\begin{tikzpicture}[xscale=1,yscale=1]
% Styles (MODIFIABLES)
\tikzstyle{fleche}=[->,>=latex,thick]
\tikzstyle{noeud}=[fill=lightgray,rectangle,draw]
\tikzstyle{feuille}=[fill=lightgray,rectangle,draw]
\tikzstyle{etiquette}=[midway,fill=white]
% Dimensions (MODIFIABLES)
\def\DistanceInterNiveaux{3}
\def\DistanceInterFeuilles{2}
% Dimensions calculées (NON MODIFIABLES)
\def\NiveauA{(-0)*\DistanceInterNiveaux}
\def\NiveauB{(-0.7)*\DistanceInterNiveaux}
\def\NiveauC{(-1.4)*\DistanceInterNiveaux}
\def\NiveauD{(-2.1)*\DistanceInterNiveaux}
\def\InterFeuilles{(1)*\DistanceInterFeuilles}
% Noeuds (MODIFIABLES : Styles et Coefficients d'InterFeuilles)
\node[noeud] (R) at ({(2)*\InterFeuilles},{\NiveauA}) {$11$};
\node[noeud] (Ra) at ({(0.5)*\InterFeuilles},{\NiveauB}) {$6$};
\node[feuille] (Raa) at ({(0)*\InterFeuilles},{\NiveauC}) {$a$};
\node[feuille] (Rab) at ({(1)*\InterFeuilles},{\NiveauC}) {$b$};
\node[noeud] (Rb) at ({(3)*\InterFeuilles},{\NiveauB}) {$5$};
\node[noeud] (Rba) at ({(2.5)*\InterFeuilles},{\NiveauC}) {$3$};
\node[feuille] (Rbaa) at ({(2)*\InterFeuilles},{\NiveauD}) {$d$};
\node[feuille] (Rbab) at ({(3)*\InterFeuilles},{\NiveauD}) {$y$};
\node[feuille] (Rbb) at ({(4)*\InterFeuilles},{\NiveauC}) {$o$};
% Arcs (MODIFIABLES : Styles)
\draw[fleche] (R)--(Ra) node[etiquette] {$0$};
\draw[fleche] (Ra)--(Raa) node[etiquette] {$0$};
\draw[fleche] (Ra)--(Rab) node[etiquette] {$1$};
\draw[fleche] (R)--(Rb) node[etiquette] {$1$};
\draw[fleche] (Rb)--(Rba) node[etiquette] {$0$};
\draw[fleche] (Rba)--(Rbaa) node[etiquette] {$0$};
\draw[fleche] (Rba)--(Rbab) node[etiquette] {$1$};
\draw[fleche] (Rb)--(Rbb) node[etiquette] {$1$};
\end{tikzpicture}
\end{center}
On obtient ainsi des codes sans préfixe pour chaque symbole.
\par\begin{tabular}{|c|c|c|c|c|c|}
\hline
Symbole & a & b & d & o & y \\
\hline
Code & 00 & 01 & 100 & 11 & 101 \\
\hline
Taille code & 2 & 2 & 3 & 2 & 3 \\
\hline
\end{tabular}
\par La longueur totale de l'encodage de la chaîne sera : $2*4 + 2*2 + 3*2 + 2*2 + 2*1 = 25$ bits. Le nombre de symboles moyen encodés par bit est de $\frac{25}{11} \simeq 2,27 > 2,19 \simeq H(X)$.
\end{example}

	\subsection{Codage de Huffman}

L'approche du codage de Shannon-Fano est descendante : l'algorithme part de l'ensemble des symboles et divise cet ensemble récursivement jusqu'à arriver à des parties ne contenant qu'un seul symbole. L'inconvénient de cette approche est que, lorsqu'il n'est pas possible de séparer un ensemble de symboles et deux sous-ensembles de probabilités à peu près égales (c'est-à-dire lorsque l'un des sous-ensembles est beaucoup plus probable que l'autre), les codes produits ne sont pas optimaux.
\par Le codage de Huffman a une approche ascendante : l'algorithme part des symboles et regroupe ceux ayant la probabilité la plus faible, jusqu'à avoir regroupé tous les symboles. Cette approche permet d'obtenir systématiquement un code optimal au niveau du symbole, dans le pire cas de la même longueur que le code de Shannon-Fano équivalent, dans tous les autres cas plus court.

\begin{algorithm}[H]
\caption{Algorithme de Huffman}
Pour chaque symbole, créer une feuille, l'associer avec sa fréquence d'apparition et l'ajouter à une file de priorité\;
\While{il y a plus d'un nœud associé à une fréquence dans la file}
{
	Supprimer de la file les 2 nœuds ayant la fréquence la plus faible\;
	Créer un nouveau nœud ayant pour fils les 2 nœuds supprimés, l'associer à la somme des fréquences des nœuds fils\;
	Ajouter le nouveau nœud à la file\;
}
Le nœud restant dans la file est la racine de l'arbre\;
\end{algorithm}

\begin{example}
\par Reprenons l'exemple \ref{ex:entropie_shannon} avec $X = yabadabadoo$. Les étapes de construction de l'arbre de Huffman sont les suivantes :
\begin{itemize}
\item[1]
%:-+-+-+- Engendré par : http://math.et.info.free.fr/TikZ/Arbre/
\begin{center}
% Racine en Haut, développement vers le bas
\begin{tikzpicture}[xscale=1,yscale=1]
% Styles (MODIFIABLES)
\tikzstyle{fleche}=[->,>=latex,thick]
\tikzstyle{noeudTransparent}=[]
\tikzstyle{noeud}=[fill=lightgray,rectangle,draw]
\tikzstyle{feuille}=[fill=lightgray,rectangle,draw]
\tikzstyle{etiquette}=[]
% Dimensions (MODIFIABLES)
\def\DistanceInterNiveaux{3}
\def\DistanceInterFeuilles{2}
% Dimensions calculées (NON MODIFIABLES)
\def\NiveauA{(-0)*\DistanceInterNiveaux}
\def\NiveauB{(-0)*\DistanceInterNiveaux}
\def\NiveauC{(-0.5)*\DistanceInterNiveaux}
\def\InterFeuilles{(1)*\DistanceInterFeuilles}
% Noeuds (MODIFIABLES : Styles et Coefficients d'InterFeuilles)
\node[noeudTransparent] (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {$ $};
\node[feuille] (Raa) at ({(0)*\InterFeuilles},{\NiveauC}) {$a:4$};
\node[noeudTransparent] (Rb) at ({(1)*\InterFeuilles},{\NiveauB}) {$ $};
\node[feuille] (Rba) at ({(1)*\InterFeuilles},{\NiveauC}) {$b:2$};
\node[noeudTransparent] (Rc) at ({(2)*\InterFeuilles},{\NiveauB}) {$ $};
\node[feuille] (Rca) at ({(2)*\InterFeuilles},{\NiveauC}) {$d:2$};
\node[noeudTransparent] (Rd) at ({(3)*\InterFeuilles},{\NiveauB}) {$ $};
\node[feuille] (Rda) at ({(3)*\InterFeuilles},{\NiveauC}) {$o:2$};
\node[noeudTransparent] (Re) at ({(4)*\InterFeuilles},{\NiveauB}) {$ $};
\node[feuille] (Rea) at ({(4)*\InterFeuilles},{\NiveauC}) {$y:1$};
% Arcs (MODIFIABLES : Styles)
\draw[fleche] (Ra)--(Raa) node[etiquette] {$ $};
\draw[fleche] (Rb)--(Rba) node[etiquette] {$ $};
\draw[fleche] (Rc)--(Rca) node[etiquette] {$ $};
\draw[fleche] (Rd)--(Rda) node[etiquette] {$ $};
\draw[fleche] (Re)--(Rea) node[etiquette] {$ $};
\end{tikzpicture}
\end{center}
%:-+-+-+-+- Fin
\item[2]
%:-+-+-+- Engendré par : http://math.et.info.free.fr/TikZ/Arbre/
\begin{center}
% Racine en Haut, développement vers le bas
\begin{tikzpicture}[xscale=1,yscale=1]
% Styles (MODIFIABLES)
\tikzstyle{fleche}=[->,>=latex,thick]
\tikzstyle{noeudTransparent}=[]
\tikzstyle{noeud}=[fill=lightgray,rectangle,draw]
\tikzstyle{feuille}=[fill=lightgray,rectangle,draw]
\tikzstyle{etiquette}=[]
% Dimensions (MODIFIABLES)
\def\DistanceInterNiveaux{3}
\def\DistanceInterFeuilles{2}
% Dimensions calculées (NON MODIFIABLES)
\def\NiveauA{(-0)*\DistanceInterNiveaux}
\def\NiveauB{(-0)*\DistanceInterNiveaux}
\def\NiveauC{(-0.5)*\DistanceInterNiveaux}
\def\NiveauD{(-1)*\DistanceInterNiveaux}
\def\InterFeuilles{(1)*\DistanceInterFeuilles}
% Noeuds (MODIFIABLES : Styles et Coefficients d'InterFeuilles)
\node[noeudTransparent] (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {$ $};
\node[feuille] (Raa) at ({(0)*\InterFeuilles},{\NiveauC}) {$a:4$};
\node[noeudTransparent] (Rb) at ({(1)*\InterFeuilles},{\NiveauB}) {$ $};
\node[feuille] (Rba) at ({(1)*\InterFeuilles},{\NiveauC}) {$b:2$};
\node[noeudTransparent] (Rc) at ({(2)*\InterFeuilles},{\NiveauB}) {$ $};
\node[feuille] (Rca) at ({(2)*\InterFeuilles},{\NiveauC}) {$d:2$};
\node[noeudTransparent] (Rd) at ({(3.5)*\InterFeuilles},{\NiveauB}) {$ $};
\node[noeud] (Rda) at ({(3.5)*\InterFeuilles},{\NiveauC}) {$3$};
\node[feuille] (Rdaa) at ({(3)*\InterFeuilles},{\NiveauD}) {$o$};
\node[feuille] (Rdab) at ({(4)*\InterFeuilles},{\NiveauD}) {$y$};
% Arcs (MODIFIABLES : Styles)
\draw[fleche] (Ra)--(Raa) node[etiquette] {$ $};
\draw[fleche] (Rb)--(Rba) node[etiquette] {$ $};
\draw[fleche] (Rc)--(Rca) node[etiquette] {$ $};
\draw[fleche] (Rd)--(Rda) node[etiquette] {$ $};
\draw[fleche] (Rda)--(Rdaa) node[etiquette] {$ $};
\draw[fleche] (Rda)--(Rdab) node[etiquette] {$ $};
\end{tikzpicture}
\end{center}
%:-+-+-+-+- Fin
\item[3]
%:-+-+-+- Engendré par : http://math.et.info.free.fr/TikZ/Arbre/
\begin{center}
% Racine en Haut, développement vers le bas
\begin{tikzpicture}[xscale=1,yscale=1]
% Styles (MODIFIABLES)
\tikzstyle{fleche}=[->,>=latex,thick]
\tikzstyle{noeudTransparent}=[]
\tikzstyle{noeud}=[fill=lightgray,rectangle,draw]
\tikzstyle{feuille}=[fill=lightgray,rectangle,draw]
\tikzstyle{etiquette}=[]
% Dimensions (MODIFIABLES)
\def\DistanceInterNiveaux{3}
\def\DistanceInterFeuilles{2}
% Dimensions calculées (NON MODIFIABLES)
\def\NiveauA{(-0)*\DistanceInterNiveaux}
\def\NiveauB{(-0)*\DistanceInterNiveaux}
\def\NiveauC{(-0.5)*\DistanceInterNiveaux}
\def\NiveauD{(-1)*\DistanceInterNiveaux}
\def\InterFeuilles{(1)*\DistanceInterFeuilles}
% Noeuds (MODIFIABLES : Styles et Coefficients d'InterFeuilles)
\node[noeudTransparent] (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {$ $};
\node[feuille] (Raa) at ({(0)*\InterFeuilles},{\NiveauC}) {$a:4$};
\node[noeudTransparent] (Rb) at ({(1.5)*\InterFeuilles},{\NiveauB}) {$ $};
\node[noeud] (Rba) at ({(1.5)*\InterFeuilles},{\NiveauC}) {$4$};
\node[feuille] (Rbaa) at ({(1)*\InterFeuilles},{\NiveauD}) {$b$};
\node[feuille] (Rbab) at ({(2)*\InterFeuilles},{\NiveauD}) {$d$};
\node[noeudTransparent] (Rc) at ({(3.5)*\InterFeuilles},{\NiveauB}) {$ $};
\node[noeud] (Rca) at ({(3.5)*\InterFeuilles},{\NiveauC}) {$3$};
\node[feuille] (Rcaa) at ({(3)*\InterFeuilles},{\NiveauD}) {$o$};
\node[feuille] (Rcab) at ({(4)*\InterFeuilles},{\NiveauD}) {$y$};
% Arcs (MODIFIABLES : Styles)
\draw[fleche] (Ra)--(Raa) node[etiquette] {$ $};
\draw[fleche] (Rb)--(Rba) node[etiquette] {$ $};
\draw[fleche] (Rba)--(Rbaa) node[etiquette] {$ $};
\draw[fleche] (Rba)--(Rbab) node[etiquette] {$ $};
\draw[fleche] (Rc)--(Rca) node[etiquette] {$ $};
\draw[fleche] (Rca)--(Rcaa) node[etiquette] {$ $};
\draw[fleche] (Rca)--(Rcab) node[etiquette] {$ $};
\end{tikzpicture}
\end{center}
%:-+-+-+-+- Fin
\item[4]
%:-+-+-+- Engendré par : http://math.et.info.free.fr/TikZ/Arbre/
\begin{center}
% Racine en Haut, développement vers le bas
\begin{tikzpicture}[xscale=1,yscale=1]
% Styles (MODIFIABLES)
\tikzstyle{fleche}=[->,>=latex,thick]
\tikzstyle{noeudTransparent}=[]
\tikzstyle{noeud}=[fill=lightgray,rectangle,draw]
\tikzstyle{feuille}=[fill=lightgray,rectangle,draw]
\tikzstyle{etiquette}=[]
% Dimensions (MODIFIABLES)
\def\DistanceInterNiveaux{3}
\def\DistanceInterFeuilles{2}
% Dimensions calculées (NON MODIFIABLES)
\def\NiveauA{(-0)*\DistanceInterNiveaux}
\def\NiveauB{(-0)*\DistanceInterNiveaux}
\def\NiveauC{(-0.5)*\DistanceInterNiveaux}
\def\NiveauD{(-1)*\DistanceInterNiveaux}
\def\NiveauE{(-1.5)*\DistanceInterNiveaux}
\def\InterFeuilles{(1)*\DistanceInterFeuilles}
% Noeuds (MODIFIABLES : Styles et Coefficients d'InterFeuilles)
\node[noeudTransparent] (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {$ $};
\node[feuille] (Raa) at ({(0)*\InterFeuilles},{\NiveauC}) {$a:4$};
\node[noeudTransparent] (Rb) at ({(2.5)*\InterFeuilles},{\NiveauB}) {$ $};
\node[noeud] (Rba) at ({(2.5)*\InterFeuilles},{\NiveauC}) {$7$};
\node[noeud] (Rbaa) at ({(1.5)*\InterFeuilles},{\NiveauD}) {$4$};
\node[feuille] (Rbaaa) at ({(1)*\InterFeuilles},{\NiveauE}) {$b$};
\node[feuille] (Rbaab) at ({(2)*\InterFeuilles},{\NiveauE}) {$d$};
\node[noeud] (Rbab) at ({(3.5)*\InterFeuilles},{\NiveauD}) {$3$};
\node[feuille] (Rbaba) at ({(3)*\InterFeuilles},{\NiveauE}) {$o$};
\node[feuille] (Rbabb) at ({(4)*\InterFeuilles},{\NiveauE}) {$y$};
% Arcs (MODIFIABLES : Styles)
\draw[fleche] (Ra)--(Raa) node[etiquette] {$ $};
\draw[fleche] (Rb)--(Rba) node[etiquette] {$ $};
\draw[fleche] (Rba)--(Rbaa) node[etiquette] {$ $};
\draw[fleche] (Rbaa)--(Rbaaa) node[etiquette] {$ $};
\draw[fleche] (Rbaa)--(Rbaab) node[etiquette] {$ $};
\draw[fleche] (Rba)--(Rbab) node[etiquette] {$ $};
\draw[fleche] (Rbab)--(Rbaba) node[etiquette] {$ $};
\draw[fleche] (Rbab)--(Rbabb) node[etiquette] {$ $};
\end{tikzpicture}
\end{center}
%:-+-+-+-+- Fin
\item[5]%:-+-+-+- Engendré par : http://math.et.info.free.fr/TikZ/Arbre/
\begin{center}
% Racine en Haut, développement vers le bas
\begin{tikzpicture}[xscale=1,yscale=1]
% Styles (MODIFIABLES)
\tikzstyle{fleche}=[->,>=latex,thick]
\tikzstyle{etiquette}=[midway,fill=white]
\tikzstyle{noeud}=[fill=lightgray,rectangle,draw]
\tikzstyle{feuille}=[fill=lightgray,rectangle,draw]
% Dimensions (MODIFIABLES)
\def\DistanceInterNiveaux{3}
\def\DistanceInterFeuilles{2}
% Dimensions calculées (NON MODIFIABLES)
\def\NiveauA{(-0)*\DistanceInterNiveaux}
\def\NiveauB{(-0.5)*\DistanceInterNiveaux}
\def\NiveauC{(-1)*\DistanceInterNiveaux}
\def\NiveauD{(-1.5)*\DistanceInterNiveaux}
\def\InterFeuilles{(1)*\DistanceInterFeuilles}
% Noeuds (MODIFIABLES : Styles et Coefficients d'InterFeuilles)
\node[noeud] (R) at ({(1)*\InterFeuilles},{\NiveauA}) {$11$};
\node[feuille] (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {$a$};
\node[noeud] (Rb) at ({(2.5)*\InterFeuilles},{\NiveauB}) {$7$};
\node[noeud] (Rba) at ({(1.5)*\InterFeuilles},{\NiveauC}) {$4$};
\node[feuille] (Rbaa) at ({(1)*\InterFeuilles},{\NiveauD}) {$b$};
\node[feuille] (Rbab) at ({(2)*\InterFeuilles},{\NiveauD}) {$d$};
\node[noeud] (Rbb) at ({(3.5)*\InterFeuilles},{\NiveauC}) {$3$};
\node[feuille] (Rbba) at ({(3)*\InterFeuilles},{\NiveauD}) {$o$};
\node[feuille] (Rbbb) at ({(4)*\InterFeuilles},{\NiveauD}) {$y$};
% Arcs (MODIFIABLES : Styles)
\draw[fleche] (R)--(Ra) node[etiquette] {$0$};
\draw[fleche] (R)--(Rb) node[etiquette] {$1$};
\draw[fleche] (Rb)--(Rba) node[etiquette] {$0$};
\draw[fleche] (Rba)--(Rbaa) node[etiquette] {$0$};
\draw[fleche] (Rba)--(Rbab) node[etiquette] {$1$};
\draw[fleche] (Rb)--(Rbb) node[etiquette] {$1$};
\draw[fleche] (Rbb)--(Rbba) node[etiquette] {$0$};
\draw[fleche] (Rbb)--(Rbbb) node[etiquette] {$1$};
\end{tikzpicture}
\end{center}
%:-+-+-+-+- Fin
\end{itemize}
On obtient ainsi des codes sans préfixe pour chaque symbole.
\par\begin{tabular}{|c|c|c|c|c|c|}
\hline
Symbole & a & b & d & o & y \\
\hline
Code & 0 & 100 & 101 & 110 & 111 \\
\hline
Taille code & 1 & 3 & 3 & 3 & 3 \\
\hline
\end{tabular}
\par La longueur totale de l'encodage de la chaîne sera : $1*4 + 3*7 = 25$ bits. Le nombre de symboles moyen encodés par bit est de $\frac{25}{11} \simeq 2,27 > 2,19 \simeq H(X)$. On constate qu'on est sur un cas avec la même moyenne que Shannon-Fano.
\end{example}

	\subsection{Codage Move-to-Front}
	
        \input{MTF.tex}

\section*{Annexe}
\subsection*{Sources}
\begin{itemize}
\item \href{https://www.sciencepresse.qc.ca/blogue/2014/12/24/mesurer-linformation-selon-hartley}{Mesurer l'information selon Hartley}
\item \href{https://fr.wikipedia.org/wiki/Entropie_de_Shannon}{Entropie de Shannon}
\item \href{https://centenaire-shannon.cnrs.fr/chapter/la-theorie-de-information}{Claude Shannon : Le monde en binaire}
\item \href{https://en.wikipedia.org/wiki/Kraft\%E2\%80\%93McMillan_inequality}{Kraft–McMillan inequality}
\item \href{https://fr.wikipedia.org/wiki/Codage_de_Shannon-Fano}{Codage de Shannon-Fano}
\item \href{https://en.wikipedia.org/wiki/Shannon\%E2\%80\%93Fano_coding}{Shannon–Fano coding}
\end{itemize}


\end{document}